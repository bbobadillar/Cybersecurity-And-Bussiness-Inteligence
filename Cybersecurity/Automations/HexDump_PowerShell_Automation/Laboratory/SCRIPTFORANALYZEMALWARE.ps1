<#
.SYNOPSIS
    HexDump and Byte Extraction Tool

.DESCRIPTION
     This script analyzes a hexdump text file generated by a prior extraction step.
    It reads the file bit-by-bit, using a dictionary of known command keywords
    (typically found in embedded batch payloads), and maps their positions.

    The script identifies where and how potentially malicious code has been embedded
    or stored in memory, helping trace the affected binary blocks.

    All findings are exported to a structured TXT file for documentation and further analysis.
    Ideal for cybersecurity training, binary inspection, and understanding attacker movement
    through memory and file systems.

.AUTHOR
    춸 2025 Bryan Bobadilla (Cybersecurity & BI Specialist)
    LinkedIn: https://www.linkedin.com/in/bryan-bobadilla/
    GitHub: https://github.com/bbobadillar

.NOTES
    For educational use only. This tool is distributed for learning, personal R&D, and responsible testing.
    Unauthorized use in production environments or against third-party systems is not permitted.

.VERSION
    1.0.0

.LICENSE
    MIT License (except for commercial redistribution)

.ENJOY
    Explore, learn, and analyze with passion. Stay curious and stay secure. 仇벒잺游댏
#>


# ?? Ajustar ruta autom치ticamente para consola o ejecuci칩n directa
 $scriptRoot = if ($PSScriptRoot) { $PSScriptRoot } else { (Get-Location).Path }
 $hexDumpPath = Join-Path $scriptRoot "imagen_hex_dump.txt"
 $exportPath = Join-Path $scriptRoot "Findings_MalwareAnalysis.txt"

 # ?? Verifica que el archivo hex exista
 if (!(Test-Path $hexDumpPath)) {
     Write-Host "? Archivo no encontrado: $hexDumpPath" -ForegroundColor Red
     exit
 }

 # ?? Palabras clave de an치lisis basado en el batch file simulado
 $maliciousKeywords = @(
     'echo',
     'mkdir',
     'copy',
     'start',
     '%APPDATA%',
     'calc.exe',
     'bad.exe',
     'System32'
 )

 # ?? Leer contenido del volcado hex
 $lines = Get-Content $hexDumpPath
 $results = @()

 foreach ($i in 0..($lines.Count - 1)) {
     $line = $lines[$i]
     foreach ($keyword in $maliciousKeywords) {
         if ($line -match $keyword) {
             $offset = $line.Substring(0, 8)
             $results += [PSCustomObject]@{
                 Offset     = "0x$offset"
                 Keyword    = $keyword
                 LinePreview = $line.Trim()
                 LineNumber = $i
             }
         }
     }
 }

 # ?? Iniciar archivo de salida
 "?? An치lisis de imagen embebida - Hex Dump" | Out-File -FilePath $exportPath -Encoding UTF8
 "Fecha de an치lisis: $(Get-Date)" | Out-File -Append $exportPath
 "`n==============================================" | Out-File -Append $exportPath

 if ($results.Count -gt 0) {
     "`n?? Coincidencias encontradas:`n" | Out-File -Append $exportPath
     $results | ForEach-Object {
         $line = $_
         "Offset: $($line.Offset) | Palabra clave: $($line.Keyword)" | Out-File -Append $exportPath
         "Contenido Hex/ASCII: $($line.LinePreview)" | Out-File -Append $exportPath
         "-----------------------------------------" | Out-File -Append $exportPath
     }

     # ?? Determinar bloque sospechoso
     $startLine = ($results | Measure-Object -Property LineNumber -Minimum).Minimum
     $endLine   = ($results | Measure-Object -Property LineNumber -Maximum).Maximum

     $contextBefore = 5
     $contextAfter = 5
     $startLine = [Math]::Max(0, $startLine - $contextBefore)
     $endLine = [Math]::Min($lines.Count - 1, $endLine + $contextAfter)

     "`n?? Bloque sospechoso completo (l칤neas $startLine a $endLine):`n" | Out-File -Append $exportPath
     for ($j = $startLine; $j -le $endLine; $j++) {
         $lines[$j] | Out-File -Append $exportPath
     }

     Write-Host "`n? Exportaci칩n finalizada en:`n$exportPath" -ForegroundColor Green
 }
 else {
     "? An치lisis limpio. No se encontraron coincidencias sospechosas." | Out-File -Append $exportPath
     Write-Host "`n? An치lisis limpio. No se encontraron coincidencias sospechosas." -ForegroundColor Green
 }








